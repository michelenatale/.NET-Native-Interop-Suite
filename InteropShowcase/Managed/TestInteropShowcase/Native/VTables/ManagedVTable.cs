
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


namespace michele.natale.RingBufferNative;


/// <summary>
/// Represents the unmanaged function table (V‑Table) that exposes managed
/// service methods to native code.  
/// Each entry contains a true unmanaged function pointer generated by NativeAOT.
/// </summary>
[StructLayout(LayoutKind.Sequential)]
internal unsafe struct ManagedServiceVTable
{
  /// <summary>
  /// Pointer to the unmanaged logging function.
  /// Accepts a UTF‑8 encoded byte pointer.
  /// </summary>
  public delegate* unmanaged<byte*, void> Log;

  /// <summary>
  /// Pointer to the unmanaged addition function.
  /// Accepts two integers and returns their sum.
  /// </summary>
  public delegate* unmanaged<int, int, int> Add;
}

/// <summary>
/// Provides the managed implementation of the service interface exposed to native code.
/// NativeAOT compiles the callback methods as true unmanaged entry points, allowing
/// C++ to invoke them directly through the V‑Table without delegates or runtime stubs.
/// </summary>
public static unsafe class ManagedService
{
  private static readonly delegate* unmanaged<byte*, void> MLogPtr = &LogImpl;
  private static readonly delegate* unmanaged<int, int, int> MAddPtr = &AddImpl;

  private static ManagedServiceVTable MVTable = new()
  {
    Log = MLogPtr,
    Add = MAddPtr
  };

  /// <summary>
  /// Gets a pointer to the unmanaged V‑Table containing all exported service functions.
  /// This pointer can be passed directly to native code, which may call the functions
  /// as if they were implemented in C or C++.
  /// </summary>
  public static IntPtr VTablePtr =>
      (IntPtr)Unsafe.AsPointer(ref MVTable);

  [UnmanagedCallersOnly]
  private static void LogImpl(byte* msg)
  {
    var str = Marshal.PtrToStringUTF8((IntPtr)msg)!;
    Console.WriteLine($"[Managed] {str}");
  }

  [UnmanagedCallersOnly]
  private static int AddImpl(int a, int b) => a + b;
}

